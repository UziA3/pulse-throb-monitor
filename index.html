<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pulse Throb Monitor with PLV</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  #canvas { border: 1px solid #ccc; }
  button { margin: 5px; }
  #recordingsList { margin-top: 10px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor with PLV Calculation</h1>

<canvas id="canvas" width="800" height="200"></canvas><br/>

<button id="connectBtn">Connect Pulse Sensor</button>
<button id="startBtn" disabled>Start Recording</button>
<button id="pauseBtn" disabled>Pause Recording</button>
<button id="resumeBtn" disabled>Resume Recording</button>
<button id="stopBtn" disabled>Stop Recording</button>
<button id="throbBtn" disabled>Mark Throb</button>

<div>Timer: <span id="timer">00:00</span></div>

<h3>Recordings:</h3>
<ul id="recordingsList"></ul>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const connectBtn = document.getElementById('connectBtn');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const throbBtn = document.getElementById('throbBtn');
  const timerDisplay = document.getElementById('timer');
  const recordingsList = document.getElementById('recordingsList');

  let device;
  let pulseCharacteristic;

  // Simulation variables for pulse wave
  let pulseWave = []; // {time, value}
  let throbs = [];    // {time, phase}
  let recordingStartTime = null;
  let timerInterval = null;
  let isRecording = false;
  let isPaused = false;
  let recordingElapsed = 0;

  let animationId;

  // Constants for waveform simulation (remove if real device connected)
  const WAVE_FREQ = 1.2; // ~72 bpm
  const WAVE_AMPLITUDE = 50;
  const WAVE_BASELINE = 100;

  // Time in ms between samples (simulate ~50Hz)
  const SAMPLE_INTERVAL = 20;

  // Keep pulse data only for last 20 seconds to display
  const DISPLAY_DURATION = 20000;

  // Connect to Bluetooth pulse sensor (HRM)
  connectBtn.onclick = async () => {
    try {
      device = await navigator.bluetooth.requestDevice({
        filters: [{ services: ['heart_rate'] }]
      });
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('heart_rate');
      pulseCharacteristic = await service.getCharacteristic('heart_rate_measurement');
      await pulseCharacteristic.startNotifications();
      pulseCharacteristic.addEventListener('characteristicvaluechanged', onPulseData);
      connectBtn.disabled = true;
      startBtn.disabled = false;
      throbBtn.disabled = false;
      alert('Connected to pulse sensor');
    } catch (err) {
      alert('Failed to connect: ' + err);
    }
  };

  // Handle incoming pulse data from Bluetooth device
  function onPulseData(event) {
    if (!isRecording || isPaused) return;
    const value = event.target.value;
    // Parse HRM data (simplified)
    let offset = 1;
    const hr = value.getUint8(offset);
    offset++;
    // Simulate pulse waveform as sine wave for visualization, but sync to HR approx
    const now = performance.now();
    pulseWave.push({ time: now, value: WAVE_BASELINE + WAVE_AMPLITUDE * Math.sin(2 * Math.PI * WAVE_FREQ * (now / 1000)) });
    cleanupPulseWave();
  }

  // Remove old pulse data beyond display window
  function cleanupPulseWave() {
    const now = performance.now();
    pulseWave = pulseWave.filter(p => p.time >= now - DISPLAY_DURATION);
  }

  // Drawing function
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw pulse waveform
    if (pulseWave.length < 2) {
      animationId = requestAnimationFrame(draw);
      return;
    }
    const now = performance.now();
    const startTime = now - DISPLAY_DURATION;
    ctx.beginPath();
    for (let i = 0; i < pulseWave.length; i++) {
      const p = pulseWave[i];
      const x = ((p.time - startTime) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - p.value;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs at exact timepoints
    throbs.forEach(throb => {
      if (throb.time < startTime || throb.time > now) return;
      // Find pulse value at throb.time by interpolation
      let pulseVal = interpolatePulseValue(throb.time);
      if (pulseVal === null) return;
      const x = ((throb.time - startTime) / DISPLAY_DURATION) * canvas.width;
      const y = canvas.height - pulseVal;
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, 2 * Math.PI);
      ctx.fillStyle = 'red';
      ctx.fill();
    });

    animationId = requestAnimationFrame(draw);
  }

  // Linear interpolation to find pulse value at a specific time
  function interpolatePulseValue(t) {
    if (pulseWave.length === 0) return null;
    for (let i = 1; i < pulseWave.length; i++) {
      if (pulseWave[i].time >= t) {
        const p1 = pulseWave[i - 1];
        const p2 = pulseWave[i];
        const ratio = (t - p1.time) / (p2.time - p1.time);
        return p1.value + ratio * (p2.value - p1.value);
      }
    }
    return null; // Out of range
  }

  // Calculate phase angle of throb relative to pulse wave
  // Approach: Find where throb.time fits in waveform cycle and compute phase [0, 2pi]
  function calculatePhase(throbTime) {
    // Find pulse peaks around throbTime to estimate cycle period
    const peaks = findPeaksInPulse();
    if (peaks.length < 2) return null; // Not enough data

    // Find two peaks surrounding throbTime
    let prevPeak = null;
    let nextPeak = null;
    for (let i = 0; i < peaks.length - 1; i++) {
      if (peaks[i] <= throbTime && peaks[i + 1] > throbTime) {
        prevPeak = peaks[i];
        nextPeak = peaks[i + 1];
        break;
      }
    }
    if (prevPeak === null || nextPeak === null) return null;

    const cycleDuration = nextPeak - prevPeak;
    const phase = 2 * Math.PI * (throbTime - prevPeak) / cycleDuration;
    return phase;
  }

  // Detect peaks in pulseWave (simple threshold + local max)
  function findPeaksInPulse() {
    const values = pulseWave;
    const peakTimes = [];
    for (let i = 1; i < values.length - 1; i++) {
      if (values[i].value > values[i - 1].value && values[i].value > values[i + 1].value) {
        peakTimes.push(values[i].time);
      }
    }
    return peakTimes;
  }

  // Start recording
  startBtn.onclick = () => {
    isRecording = true;
    isPaused = false;
    recordingStartTime = performance.now();
    recordingElapsed = 0;
    throbs = [];
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    timerInterval = setInterval(updateTimer, 100);
    animationId = requestAnimationFrame(draw);
  };

  // Pause recording
  pauseBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    throbBtn.disabled = true;
    clearInterval(timerInterval);
  };

  // Resume recording
  resumeBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    throbBtn.disabled = false;
    // Adjust recordingStartTime so timer continues correctly
    recordingStartTime = performance.now() - recordingElapsed;
    timerInterval = setInterval(updateTimer, 100);
  };

  // Stop recording
  stopBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    clearInterval(timerInterval);
    updateTimer();
    cancelAnimationFrame(animationId);
    saveRecording();
  };

  // Update timer display
  function updateTimer() {
    recordingElapsed = performance.now() - recordingStartTime;
    const totalSeconds = Math.floor(recordingElapsed / 1000);
    const mins = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    timerDisplay.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

  // Mark a throb at current time
  throbBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    const throbTime = performance.now();
    const phase = calculatePhase(throbTime);
    throbs.push({ time: throbTime, phase: phase });
  };

  // Calculate PLV for current throbs
  function calculatePLV() {
    if (throbs.length === 0) return 0;
    let sumReal = 0;
    let sumImag = 0;
    throbs.forEach(({ phase }) => {
      if (phase === null) return;
      sumReal += Math.cos(phase);
      sumImag += Math.sin(phase);
    });
    const n = throbs.filter(t => t.phase !== null).length;
    if (n === 0) return 0;
    const plv = Math.sqrt(sumReal * sumReal + sumImag * sumImag) / n;
    return plv;
  }

  // Save recording data as CSV with PLV
  function saveRecording() {
    if (throbs.length === 0) {
      alert('No throbs marked during recording');
      return;
    }

    // Prepare CSV headers
    const header = [
      'Throb Number',
      'Throb Timestamp (ms)',
      'Phase Angle (radians)',
    ];

    // Build CSV rows
    const rows = throbs.map((throb, i) => [
      i + 1,
      (throb.time - recordingStartTime).toFixed(2),
      throb.phase !== null ? throb.phase.toFixed(4) : 'N/A',
    ]);

    // Calculate PLV
    const plv = calculatePLV();

    // Compose CSV content
    let csvContent = header.join(',') + '\n';
    rows.forEach(row => {
      csvContent += row.join(',') + '\n';
    });
    csvContent += '\n';
    csvContent += `PLV for recording:,${plv.toFixed(4)}\n`;

    // Download CSV
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `pulse_throb_recording_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    // Add recording to list with filename
    const li = document.createElement('li');
    li.textContent = a.download;
    recordingsList.appendChild(li);

    // Reset timer and throbs for next recording
    throbs = [];
    recordingElapsed = 0;
    timerDisplay.textContent = '00:00';
  }

})();
</script>

</body>
</html>
