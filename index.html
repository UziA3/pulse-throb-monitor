<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pulse Throb Monitor</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 10px;
    background: #f0f2f5;
    color: #222;
  }
  #container {
    max-width: 900px;
    margin: auto;
  }
  canvas {
    background: white;
    border: 1px solid #ccc;
    display: block;
    margin-bottom: 10px;
  }
  button, input, select {
    margin: 5px 5px 5px 0;
    padding: 8px 12px;
    font-size: 1rem;
  }
  #recordingsList {
    margin-top: 20px;
  }
  .recording-item {
    background: #fff;
    border: 1px solid #ccc;
    margin-bottom: 8px;
    padding: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .recording-name-input {
    flex-grow: 1;
    margin-right: 10px;
  }
</style>
</head>
<body>
<div id="container">
  <h1>Pulse Throb Monitor</h1>
  
  <button id="connectBtn">Connect Bluetooth Pulse Sensor</button>
  <button id="startBtn" disabled>Start Recording</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="resumeBtn" disabled>Resume</button>
  <button id="stopBtn" disabled>Stop Recording</button>
  <button id="throbBtn" disabled>Mark Throb</button>
  <span id="timer">00:00:00</span>
  
  <canvas id="waveform" width="850" height="200"></canvas>
  
  <h2>Recordings</h2>
  <div id="recordingsList"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  const connectBtn = document.getElementById('connectBtn');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const stopBtn = document.getElementById('stopBtn');
  const throbBtn = document.getElementById('throbBtn');
  const timerSpan = document.getElementById('timer');
  const recordingsList = document.getElementById('recordingsList');
  
  // Settings
  const waveformWidth = canvas.width;
  const waveformHeight = canvas.height;
  const samplingRate = 50; // samples per second
  const maxDataPoints = samplingRate * 30; // show last 30 seconds
  const pulseAmplitude = 40;
  const pulseBaseLine = waveformHeight / 2;
  
  // State variables
  let bluetoothDevice = null;
  let pulseCharacteristic = null;
  let pulseDataQueue = [];
  let isRecording = false;
  let isPaused = false;
  let recordingStartTime = null;
  let elapsedTime = 0; // ms
  let timerInterval = null;
  
  // Data for current recording
  let recordingData = {
    pulses: [],    // {time: ms, value: number}
    throbs: []     // {time: ms}
  };
  
  // List of saved recordings
  let recordings = [];
  
  // --- Helper Functions ---
  function formatTime(ms) {
    let totalSeconds = Math.floor(ms / 1000);
    let h = Math.floor(totalSeconds / 3600).toString().padStart(2,'0');
    let m = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2,'0');
    let s = (totalSeconds % 60).toString().padStart(2,'0');
    return `${h}:${m}:${s}`;
  }
  
  function drawWaveform() {
    ctx.clearRect(0, 0, waveformWidth, waveformHeight);
    
    // Background grid lines
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    for (let y = 0; y <= waveformHeight; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(waveformWidth, y);
      ctx.stroke();
    }
    
    // Draw pulse waveform line
    if (pulseDataQueue.length < 2) return;
    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const stepX = waveformWidth / (maxDataPoints - 1);
    pulseDataQueue.forEach((point, i) => {
      let x = i * stepX;
      let y = pulseBaseLine - (point.value * pulseAmplitude);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Draw throb markers exactly at the correct x based on throb time
    ctx.fillStyle = 'red';
    ctx.font = 'bold 14px Arial';
    recordingData.throbs.forEach(throb => {
      // Calculate x from throb.time relative to recording start
      if (!recordingStartTime) return;
      let relMs = throb.time - recordingStartTime;
      if (relMs < 0) return;
      let x = (relMs / 30000) * waveformWidth; // since showing last 30 sec max
      if (x < 0 || x > waveformWidth) return;
      // Get Y value at that x by interpolation
      let idx = Math.floor((x / waveformWidth) * (maxDataPoints - 1));
      let pulseVal = pulseDataQueue[idx]?.value || 0;
      let y = pulseBaseLine - (pulseVal * pulseAmplitude);
      // Draw marker as a vertical line and label
      ctx.beginPath();
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.moveTo(x, y - 15);
      ctx.lineTo(x, y + 15);
      ctx.stroke();
      ctx.fillText('Throb', x + 3, y - 18);
    });
  }
  
  function updateTimer() {
    if (!isRecording || isPaused) return;
    elapsedTime = Date.now() - recordingStartTime;
    timerSpan.textContent = formatTime(elapsedTime);
  }
  
  function resetRecordingState() {
    recordingData = { pulses: [], throbs: [] };
    pulseDataQueue = [];
    elapsedTime = 0;
    recordingStartTime = null;
    timerSpan.textContent = '00:00:00';
  }
  
  // --- Simulated pulse data (sine wave approx) ---
  let simAngle = 0;
  function generateSimPulse() {
    // 1Hz sine wave (60bpm)
    simAngle += (2 * Math.PI) / samplingRate;
    if (simAngle > 2 * Math.PI) simAngle -= 2 * Math.PI;
    return (Math.sin(simAngle) + 1) / 2; // normalized 0 to 1
  }
  
  // --- Bluetooth Pulse Sensor Integration ---
  async function connectBluetooth() {
    try {
      // This UUID corresponds to standard Heart Rate Measurement service
      const serviceUuid = 'heart_rate';
      bluetoothDevice = await navigator.bluetooth.requestDevice({
        filters: [{services: [serviceUuid]}]
      });
      
      const server = await bluetoothDevice.gatt.connect();
      const service = await server.getPrimaryService(serviceUuid);
      pulseCharacteristic = await service.getCharacteristic('heart_rate_measurement');
      
      await pulseCharacteristic.startNotifications();
      pulseCharacteristic.addEventListener('characteristicvaluechanged', handlePulseData);
      
      console.log('Bluetooth pulse sensor connected');
      connectBtn.textContent = 'Connected';
      connectBtn.disabled = true;
      startBtn.disabled = false;
      throbBtn.disabled = false;
    } catch (error) {
      alert('Bluetooth connection failed or cancelled.');
      console.error(error);
    }
  }
  
  function handlePulseData(event) {
    const value = event.target.value;
    // Parse according to BLE Heart Rate Measurement spec:
    // First byte: flags, second byte: HR value (assuming 8-bit here)
    const flags = value.getUint8(0);
    let hr;
    if (flags & 0x01) {
      hr = value.getUint16(1, /*littleEndian=*/true);
    } else {
      hr = value.getUint8(1);
    }
    
    // Normalize HR to range 0..1 for drawing (assume max 180 bpm)
    let normalized = Math.min(hr / 180, 1);
    
    addPulseData(normalized);
  }
  
  // --- Data & Drawing Loop ---
  function addPulseData(val) {
    if (pulseDataQueue.length >= maxDataPoints) pulseDataQueue.shift();
    pulseDataQueue.push({value: val, time: Date.now()});
    
    if (isRecording && !isPaused) {
      recordingData.pulses.push({time: Date.now(), value: val});
    }
  }
  
  function startRecording() {
    resetRecordingState();
    isRecording = true;
    isPaused = false;
    recordingStartTime = Date.now();
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    timerInterval = setInterval(() => {
      updateTimer();
      drawWaveform();
    }, 1000 / samplingRate);
  }
  
  function pauseRecording() {
    isPaused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
  }
  
  function resumeRecording() {
    isPaused = false;
    // Adjust recordingStartTime to keep elapsedTime correct
    recordingStartTime = Date.now() - elapsedTime;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
  }
  
  function stopRecording() {
    isRecording = false;
    isPaused = false;
    clearInterval(timerInterval);
    timerSpan.textContent = formatTime(elapsedTime);
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    
    if (recordingData.pulses.length === 0) return alert('No data recorded.');
    
    // Save recording to list
    const recName = prompt('Enter name for this recording:', `Recording ${recordings.length + 1}`) || `Recording ${recordings.length + 1}`;
    recordings.push({name: recName, data: {...recordingData}});
    renderRecordingsList();
    
    resetRecordingState();
  }
  
  function markThrob() {
    if (!isRecording || isPaused) return;
    let throbTime = Date.now();
    recordingData.throbs.push({time: throbTime});
  }
  
  function renderRecordingsList() {
    recordingsList.innerHTML = '';
    recordings.forEach((rec, i) => {
      const div = document.createElement('div');
      div.className = 'recording-item';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.value = rec.name;
      input.className = 'recording-name-input';
      input.onchange = () => rec.name = input.value;
      
      const exportBtn = document.createElement('button');
      exportBtn.textContent = 'Export CSV';
      exportBtn.onclick = () => exportRecordingCSV(rec);
      
      div.appendChild(input);
      div.appendChild(exportBtn);
      
      recordingsList.appendChild(div);
    });
  }
  
  function exportRecordingCSV(recording) {
    // CSV columns: time(ms),pulse_value,throb(0/1)
    // We'll merge pulse and throb time series
    
    // Create a map of throb times for quick lookup
    const throbTimes = new Set(recording.data.throbs.map(t => t.time));
    
    let lines = ['time(ms),pulse_value,throb'];
    
    recording.data.pulses.forEach(p => {
      const isThrob = recording.data.throbs.some(t => Math.abs(t.time - p.time) < 50) ? 1 : 0;
      lines.push(`${p.time},${p.value.toFixed(4)},${isThrob}`);
    });
    
    const csvContent = lines.join('\n');
    const blob = new Blob([csvContent], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${recording.name.replace(/\s+/g,'_')}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  // --- Main Loop for Simulation if no Bluetooth ---
  function simLoop() {
    if (!bluetoothDevice && !isPaused) {
      addPulseData(generateSimPulse());
    }
  }
  
  // --- Button Event Listeners ---
  connectBtn.onclick = connectBluetooth;
  startBtn.onclick = startRecording;
  pauseBtn.onclick = pauseRecording;
  resumeBtn.onclick = resumeRecording;
  stopBtn.onclick = stopRecording;
  throbBtn.onclick = markThrob;
  
  // Enable buttons for simulation mode
  function enableSimulationMode() {
    startBtn.disabled = false;
    throbBtn.disabled = false;
  }
  
  // Initial setup
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  
  enableSimulationMode(); // allow usage without Bluetooth
  
  // Draw loop
  setInterval(() => {
    drawWaveform();
  }, 1000 / samplingRate);
  
  // Simulate pulse if no Bluetooth connected
  setInterval(simLoop, 1000 / samplingRate);
})();
</script>
</body>
</html>
