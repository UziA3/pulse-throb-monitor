<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pulse Throb Monitor with Detailed CSV Export</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  #waveform { border: 1px solid #ccc; width: 100%; height: 150px; }
  button { margin: 5px; padding: 10px 20px; }
  #recordingsList { margin-top: 10px; }
</style>
</head>
<body>

<h1>Pulse Throb Monitor</h1>

<canvas id="waveform"></canvas>
<br />

<button id="connectBluetooth">Connect Bluetooth Device</button>
<button id="startRecord">Start Recording</button>
<button id="pauseRecord" disabled>Pause</button>
<button id="resumeRecord" disabled>Resume</button>
<button id="stopRecord" disabled>Stop Recording</button>
<button id="markThrob" disabled>Mark Throb</button>
<button id="exportCSV" disabled>Export CSV</button>

<div id="timer">Recording Time: 0.0 s</div>

<h3>Recordings:</h3>
<ul id="recordingsList"></ul>

<script>
(() => {
  const canvas = document.getElementById('waveform');
  const ctx = canvas.getContext('2d');
  canvas.width = canvas.clientWidth;
  canvas.height = 150;

  const connectBtn = document.getElementById('connectBluetooth');
  const startBtn = document.getElementById('startRecord');
  const pauseBtn = document.getElementById('pauseRecord');
  const resumeBtn = document.getElementById('resumeRecord');
  const stopBtn = document.getElementById('stopRecord');
  const throbBtn = document.getElementById('markThrob');
  const exportBtn = document.getElementById('exportCSV');
  const timerDiv = document.getElementById('timer');
  const recordingsList = document.getElementById('recordingsList');

  let recording = false;
  let paused = false;
  let startTime = 0;
  let elapsedBeforePause = 0;
  let timerInterval;

  // Arrays to store timestamps in ms (relative to recording start)
  let peaks = [];
  let throbs = [];

  // Placeholder: Simulate peaks for demo (replace with bluetooth data)
  // For real device: replace this function to push peak times as they arrive
  function simulatePeak() {
    if (!recording || paused) return;
    const now = performance.now();
    peaks.push(now - startTime);
  }

  // For demo: simulate a peak every 1s
  let simulationInterval;

  // Draw waveform placeholder (sine wave updated live)
  function drawWaveform() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const width = canvas.width;
    const height = canvas.height;
    ctx.beginPath();
    ctx.strokeStyle = '#0077cc';
    ctx.lineWidth = 2;

    const timeNow = performance.now();
    for(let x=0; x<width; x++) {
      const t = (timeNow - startTime)/1000 - (width - x)/100; // simulate scrolling wave
      const y = height/2 + 40 * Math.sin(2 * Math.PI * 1.2 * t);
      if(x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Draw throb markers at exact timepoint mapped to canvas position
    ctx.fillStyle = 'red';
    throbs.forEach(throbTime => {
      // Map throbTime (ms) relative to startTime to x coordinate on canvas:
      // We show last ~10 seconds on canvas:
      const windowMs = 10000;
      const offset = (performance.now() - startTime);
      const relativeMs = throbTime;
      const posX = width - ((offset - relativeMs) / windowMs) * width;
      if (posX >= 0 && posX <= width) {
        // y coordinate corresponds to waveform sine at that time
        const t = (throbTime / 1000) * 1.2 * 2 * Math.PI;
        const y = height/2 + 40 * Math.sin(t);
        ctx.beginPath();
        ctx.arc(posX, y, 6, 0, 2*Math.PI);
        ctx.fill();
      }
    });

    if (recording && !paused) requestAnimationFrame(drawWaveform);
  }

  function startRecording() {
    if(recording) return;
    recording = true;
    paused = false;
    startTime = performance.now();
    elapsedBeforePause = 0;
    peaks = [];
    throbs = [];
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    stopBtn.disabled = false;
    throbBtn.disabled = false;
    exportBtn.disabled = true;
    timerDiv.textContent = `Recording Time: 0.0 s`;

    // Start simulation of peaks (replace with real bluetooth data handler)
    simulationInterval = setInterval(() => {
      if(!paused) {
        const now = performance.now();
        peaks.push(now - startTime);
      }
    }, 1000); // 1 peak per second for simulation

    timerInterval = setInterval(() => {
      const elapsed = (performance.now() - startTime) / 1000;
      timerDiv.textContent = `Recording Time: ${elapsed.toFixed(1)} s`;
    }, 100);

    drawWaveform();
  }

  function pauseRecording() {
    if(!recording || paused) return;
    paused = true;
    pauseBtn.disabled = true;
    resumeBtn.disabled = false;
    clearInterval(timerInterval);
    clearInterval(simulationInterval);
  }

  function resumeRecording() {
    if(!recording || !paused) return;
    paused = false;
    pauseBtn.disabled = false;
    resumeBtn.disabled = true;
    // Adjust startTime to account for paused duration
    const pauseDuration = performance.now() - (startTime + (elapsedBeforePause * 1000));
    startTime += pauseDuration;
    elapsedBeforePause = (performance.now() - startTime) / 1000;

    // Restart simulation interval for demo
    simulationInterval = setInterval(() => {
      if(!paused) {
        const now = performance.now();
        peaks.push(now - startTime);
      }
    }, 1000);

    timerInterval = setInterval(() => {
      const elapsed = (performance.now() - startTime) / 1000;
      timerDiv.textContent = `Recording Time: ${elapsed.toFixed(1)} s`;
    }, 100);

    drawWaveform();
  }

  function stopRecording() {
    if(!recording) return;
    recording = false;
    paused = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resumeBtn.disabled = true;
    stopBtn.disabled = true;
    throbBtn.disabled = true;
    exportBtn.disabled = false;
    clearInterval(timerInterval);
    clearInterval(simulationInterval);
  }

  function markThrob() {
    if(!recording || paused) return;
    const now = performance.now();
    const throbTime = now - startTime;
    throbs.push(throbTime);
    drawWaveform(); // update with new marker
  }

  // CSV export with detailed columns
  function exportEnhancedCSV() {
    if(throbs.length === 0) {
      alert('No throbs recorded!');
      return;
    }

    let csv = 'Throb Time (ms),Preceding Peak Time (ms),Interval (ms),Next Peak Time (ms),Interval to Next Peak (ms),Pulse Cycle Duration (ms),Throb-to-Peak Ratio,Throb Phase,Time Since Start (ms)\n';

    // Sort peaks and throbs just in case
    peaks.sort((a,b) => a - b);
    throbs.sort((a,b) => a - b);

    for (const throbTime of throbs) {
      let precedingPeakIndex = -1;
      for (let i = peaks.length - 1; i >= 0; i--) {
        if (peaks[i] <= throbTime) {
          precedingPeakIndex = i;
          break;
        }
      }

      if (precedingPeakIndex === -1) {
        csv += `${throbTime},,,,,,,${throbTime}\n`;
        continue;
      }

      const precedingPeakTime = peaks[precedingPeakIndex];
      const interval = throbTime - precedingPeakTime;

      const nextPeakTime = peaks[precedingPeakIndex + 1] || '';
      const intervalToNextPeak = nextPeakTime ? nextPeakTime - throbTime : '';

      const previousPeakTime = peaks[precedingPeakIndex - 1] || '';
      const pulseCycleDuration = previousPeakTime ? precedingPeakTime - previousPeakTime : '';

      const throbToPeakRatio = pulseCycleDuration ? (interval / pulseCycleDuration) : '';
      const throbPhase = pulseCycleDuration ? (interval / pulseCycleDuration) : '';

      const timeSinceStart = throbTime;

      csv += [
        throbTime.toFixed(2),
        precedingPeakTime.toFixed(2),
        interval.toFixed(2),
        nextPeakTime ? nextPeakTime.toFixed(2) : '',
        intervalToNextPeak ? intervalToNextPeak.toFixed(2) : '',
        pulseCycleDuration ? pulseCycleDuration.toFixed(2) : '',
        throbToPeakRatio ? throbToPeakRatio.toFixed(3) : '',
        throbPhase ? throbPhase.toFixed(3) : '',
        timeSinceStart.toFixed(2)
      ].join(',') + '\n';
    }

    // Create and download CSV file
    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pulse_throb_recording_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  connectBtn.onclick = () => {
    alert('Bluetooth device connection logic to be implemented here.');
    // TODO: Implement real Bluetooth connection and update peaks array as data arrives
  };

  startBtn.onclick = startRecording;
  pauseBtn.onclick = pauseRecording;
  resumeBtn.onclick = resumeRecording;
  stopBtn.onclick = stopRecording;
  throbBtn.onclick = markThrob;
  exportBtn.onclick = exportEnhancedCSV;

  // Disable buttons that require active recording initially
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopBtn.disabled = true;
  throbBtn.disabled = true;
  exportBtn.disabled = true;

})();
</script>

</body>
</html>
