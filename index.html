<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pulse Throb Monitor - Sinusoidal Waveform</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  #pulseCanvas { border: 1px solid #ccc; display: block; margin-bottom: 10px; }
  button { margin-right: 10px; margin-bottom: 10px; padding: 8px 16px; font-size: 16px; }
  #recordingsList { margin-top: 20px; }
  .recordingItem { margin-bottom: 10px; }
</style>
</head>
<body>

<h2>Pulse Throb Monitor</h2>
<canvas id="pulseCanvas" width="600" height="200"></canvas>

<div>
  <button id="connectBtn">Connect Heart Rate Monitor</button>
  <button id="startRecordBtn" disabled>Start Recording</button>
  <button id="pauseRecordBtn" disabled>Pause Recording</button>
  <button id="resumeRecordBtn" disabled>Resume Recording</button>
  <button id="stopRecordBtn" disabled>Stop Recording</button>
  <button id="throbBtn" disabled>Mark Throb</button>
</div>

<div>
  <strong>Timer:</strong> <span id="timer">00:00</span>
</div>

<div id="recordingsList">
  <h3>Recordings</h3>
  <!-- List of saved recordings here -->
</div>

<script>
(() => {
  const canvas = document.getElementById('pulseCanvas');
  const ctx = canvas.getContext('2d');

  const connectBtn = document.getElementById('connectBtn');
  const startRecordBtn = document.getElementById('startRecordBtn');
  const pauseRecordBtn = document.getElementById('pauseRecordBtn');
  const resumeRecordBtn = document.getElementById('resumeRecordBtn');
  const stopRecordBtn = document.getElementById('stopRecordBtn');
  const throbBtn = document.getElementById('throbBtn');

  const timerDisplay = document.getElementById('timer');
  const recordingsList = document.getElementById('recordingsList');

  let heartRate = 60;
  let time = 0;
  let animationId;

  // Bluetooth variables
  let hrCharacteristic = null;

  // Recording variables
  let isRecording = false;
  let isPaused = false;
  let recordStartTime = 0;
  let elapsedBeforePause = 0;
  let recordedData = []; // {time: seconds, hr: number, throb: boolean}
  let recordings = []; // saved sessions

  // Connect to Bluetooth heart rate device
  async function connectBluetooth() {
    try {
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ services: ['heart_rate'] }],
      });

      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('heart_rate');
      hrCharacteristic = await service.getCharacteristic('heart_rate_measurement');

      await hrCharacteristic.startNotifications();
      hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRChanged);

      connectBtn.disabled = true;
      startRecordBtn.disabled = false;
      throbBtn.disabled = false;

      console.log('Connected to HR monitor');
    } catch (error) {
      alert('Bluetooth connection failed or canceled: ' + error);
    }
  }

  // Parse heart rate from characteristic
  function parseHeartRate(value) {
    value = value.buffer ? value : new DataView(value);
    let flags = value.getUint8(0);
    let rate16Bits = flags & 0x1;
    let bpm = rate16Bits ? value.getUint16(1, true) : value.getUint8(1);
    return bpm;
  }

  function handleHRChanged(event) {
    const bpm = parseHeartRate(event.target.value);
    if (bpm > 0) {
      heartRate = bpm;
    }
  }

  // Timer functions
  function formatTime(seconds) {
    const m = Math.floor(seconds / 60).toString().padStart(2, '0');
    const s = (seconds % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  }

  function updateTimer() {
    if (!isRecording || isPaused) return;
    const now = performance.now();
    const elapsed = (now - recordStartTime) / 1000 + elapsedBeforePause;
    timerDisplay.textContent = formatTime(Math.floor(elapsed));
    return elapsed;
  }

  // Drawing sinusoidal pulse wave with throbs marked
  function drawSineWave(hr, throbs) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();

    const frequency = hr / 60; // beats per second
    const amplitude = 50;
    const centerY = canvas.height / 2;

    for (let x = 0; x < canvas.width; x++) {
      // Map x to time window of 10 seconds for visualization
      const t = (time / 60) + (x / canvas.width) * 10;
      const y = centerY + amplitude * Math.sin(2 * Math.PI * frequency * t);
      if (x === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.strokeStyle = 'red';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw throbs as vertical lines on exact time
    if (throbs.length > 0) {
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      throbs.forEach(throbTime => {
        // Check if throbTime is within displayed 10-second window
        if (throbTime >= time && throbTime <= time + 10) {
          const xPos = ((throbTime - time) / 10) * canvas.width;
          ctx.beginPath();
          ctx.moveTo(xPos, 0);
          ctx.lineTo(xPos, canvas.height);
          ctx.stroke();
        }
      });
    }
  }

  // Animation loop
  let lastTimestamp = null;
  let throbTimes = [];

  function animate(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    const delta = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    if (isRecording && !isPaused) {
      time += delta; // advance time in seconds
    }

    drawSineWave(heartRate, throbTimes);

    // Record data if recording & not paused
    if (isRecording && !isPaused) {
      recordedData.push({
        time: time,
        hr: heartRate,
        throb: false
      });
    }

    animationId = requestAnimationFrame(animate);
  }

  // Button handlers

  connectBtn.onclick = () => connectBluetooth();

  startRecordBtn.onclick = () => {
    isRecording = true;
    isPaused = false;
    recordStartTime = performance.now();
    elapsedBeforePause = 0;
    recordedData = [];
    throbTimes = [];
    time = 0;

    startRecordBtn.disabled = true;
    pauseRecordBtn.disabled = false;
    resumeRecordBtn.disabled = true;
    stopRecordBtn.disabled = false;
    throbBtn.disabled = false;
  };

  pauseRecordBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    isPaused = true;
    elapsedBeforePause += (performance.now() - recordStartTime) / 1000;

    pauseRecordBtn.disabled = true;
    resumeRecordBtn.disabled = false;
  };

  resumeRecordBtn.onclick = () => {
    if (!isRecording || !isPaused) return;
    isPaused = false;
    recordStartTime = performance.now();

    pauseRecordBtn.disabled = false;
    resumeRecordBtn.disabled = true;
  };

  stopRecordBtn.onclick = () => {
    if (!isRecording) return;
    isRecording = false;
    isPaused = false;

    startRecordBtn.disabled = false;
    pauseRecordBtn.disabled = true;
    resumeRecordBtn.disabled = true;
    stopRecordBtn.disabled = true;
    throbBtn.disabled = true;

    timerDisplay.textContent = '00:00';

    // Save current recording
    saveRecording();
  };

  throbBtn.onclick = () => {
    if (!isRecording || isPaused) return;
    throbTimes.push(time);

    // Mark throb in recordedData as well
    recordedData.push({
      time: time,
      hr: heartRate,
      throb: true
    });
  };

  // Save recording as CSV with prompt to name recording
  function saveRecording() {
    let name = prompt('Enter a name for this recording:', `Recording_${recordings.length + 1}`);
    if (!name) name = `Recording_${recordings.length + 1}`;

    // Prepare CSV data: time, heart rate, throb (1 or 0)
    const csvRows = [];
    csvRows.push('time(s),heart_rate_bpm,throb');
    recordedData.forEach(row => {
      csvRows.push(`${row.time.toFixed(2)},${row.hr},${row.throb ? 1 : 0}`);
    });
    const csvContent = csvRows.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);

    recordings.push({ name, url });
    updateRecordingsList();
  }

  function updateRecordingsList() {
    const list = document.createElement('div');
    list.innerHTML = '';
    recordings.forEach((rec, idx) => {
      const div = document.createElement('div');
      div.className = 'recordingItem';
      div.innerHTML = `
        <strong>${rec.name}</strong>
        &nbsp; <a href="${rec.url}" download="${rec.name}.csv">Download CSV</a>
      `;
      list.appendChild(div);
    });
    // Clear old and append new list
    while (recordingsList.childNodes.length > 1) {
      recordingsList.removeChild(recordingsList.lastChild);
    }
    recordingsList.appendChild(list);
  }

  // Start animation
  animationId = requestAnimationFrame(animate);
})();
</script>

</body>
</html>
