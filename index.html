import React, { useEffect, useState, useRef } from "react";

const SAMPLE_RATE = 60; // 60 samples per second for waveform simulation
const WAVE_LENGTH_SEC = 10; // display last 10 seconds of waveform

export default function PulseThrobBluetooth() {
  const [connected, setConnected] = useState(false);
  const [hr, setHr] = useState(60);
  const [waveData, setWaveData] = useState([]);
  const [throbs, setThrobs] = useState([]); // { time: timestamp }
  const [recording, setRecording] = useState(false);
  const [records, setRecords] = useState([]);
  const [recordStartTime, setRecordStartTime] = useState(null);
  const [elapsed, setElapsed] = useState(0);

  const hrmDevice = useRef(null);
  const hrmCharacteristic = useRef(null);
  const waveTimer = useRef(null);
  const clockTimer = useRef(null);
  const startTime = useRef(null);

  // Connect to Bluetooth HRM device
  async function connect() {
    try {
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ services: ["heart_rate"] }],
      });
      hrmDevice.current = device;
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService("heart_rate");
      const characteristic = await service.getCharacteristic("heart_rate_measurement");
      hrmCharacteristic.current = characteristic;

      characteristic.startNotifications();
      characteristic.addEventListener("characteristicvaluechanged", handleHRMData);

      setConnected(true);
      startTime.current = performance.now();
      if (!waveTimer.current) startWaveTimer();
      if (!clockTimer.current) startClock();
    } catch (e) {
      alert("Bluetooth connection failed: " + e);
    }
  }

  // Parse HRM data event
  function handleHRMData(event) {
    const value = event.target.value;
    // Heart Rate Measurement format per BLE spec
    // First byte flags, second byte HR value (8 or 16 bit)
    let flags = value.getUint8(0);
    let hrValue;
    if (flags & 0x1) hrValue = value.getUint16(1, /*littleEndian=*/true);
    else hrValue = value.getUint8(1);
    setHr(hrValue);
  }

  // Generate waveform points based on HR
  function startWaveTimer() {
    waveTimer.current = setInterval(() => {
      setWaveData((prev) => {
        const now = performance.now();
        if (!startTime.current) startTime.current = now;
        const t = (now - startTime.current) / 1000;
        // Simulate pulse wave as a sine wave with frequency = hr / 60
        const freq = hr / 60;
        const y = Math.sin(2 * Math.PI * freq * t);
        const newData = [...prev, { t, y }];
        // Keep only last WAVE_LENGTH_SEC seconds
        return newData.filter((pt) => pt.t >= t - WAVE_LENGTH_SEC);
      });
    }, 1000 / SAMPLE_RATE);
  }

  // Clock for recording timer
  function startClock() {
    clockTimer.current = setInterval(() => {
      if (recording && recordStartTime) {
        setElapsed((performance.now() - recordStartTime) / 1000);
      }
    }, 100);
  }

  // Start recording session
  function startRecording() {
    setRecording(true);
    setThrobs([]);
    setRecordStartTime(performance.now());
    setElapsed(0);
  }

  // Stop recording session
  function stopRecording() {
    setRecording(false);
    // Save recording data: throbs with relative time, waveform segment
    const endTime = performance.now();
    const startT = (recordStartTime - startTime.current) / 1000;
    const endT = (endTime - startTime.current) / 1000;

    // Get waveform data in recording window
    const waveSlice = waveData.filter((pt) => pt.t >= startT && pt.t <= endT);
    // Throbs relative to start recording time
    const throbsRel = throbs.map((throb) => ({
      time: (throb.time - recordStartTime) / 1000,
    }));
    const rec = {
      id: Date.now(),
      start: startT,
      end: endT,
      throbs: throbsRel,
      waveform: waveSlice,
    };
    setRecords((prev) => [...prev, rec]);
    setThrobs([]);
    setElapsed(0);
  }

  // Pause / resume recording
  // (For simplicity, pause stops wave collection and timer, resume restarts with offset)
  // Not implemented here for brevity but can be added

  // On throb button press: record timestamp (performance.now())
  function handleThrob() {
    if (!recording) return alert("Start recording first!");
    setThrobs((prev) => [...prev, { time: performance.now() }]);
  }

  // Download CSV of a recording
  function downloadCSV(record) {
    let csv = "time(s),wave_y,throb_marker\n";
    // Merge waveform and throbs by closest timestamps
    let waveIdx = 0,
      throbIdx = 0;
    const wave = record.waveform;
    const throbs = record.throbs;

    for (let i = 0; i < wave.length; i++) {
      const wt = wave[i].t;
      const relT = wt - record.start;
      // Check if throb occurs close to this time (within 50ms)
      let mark = "";
      while (throbIdx < throbs.length && Math.abs(throbs[throbIdx].time - relT) < 0.05) {
        mark = "THROB";
        throbIdx++;
      }
      csv += `${relT.toFixed(3)},${wave[i].y.toFixed(4)},${mark}\n`;
    }

    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `recording_${record.id}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Render waveform and markers on canvas
  function WaveformCanvas() {
    const canvasRef = useRef(null);

    useEffect(() => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      ctx.clearRect(0, 0, width, height);

      // Draw waveform
      ctx.beginPath();
      ctx.strokeStyle = "#0077cc";
      ctx.lineWidth = 2;
      const now = performance.now();
      const baseTime = (startTime.current ? (now - startTime.current) / 1000 : 0);

      // Draw only points within [baseTime - WAVE_LENGTH_SEC, baseTime]
      const visibleWave = waveData.filter((pt) => pt.t >= baseTime - WAVE_LENGTH_SEC && pt.t <= baseTime);

      if (visibleWave.length > 0) {
        visibleWave.forEach((pt, i) => {
          const x = ((pt.t - (baseTime - WAVE_LENGTH_SEC)) / WAVE_LENGTH_SEC) * width;
          const y = height / 2 - pt.y * (height / 3);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
      }
      ctx.stroke();

      // Draw throb markers at exact times on waveform timeline
      ctx.fillStyle = "red";
      ctx.strokeStyle = "darkred";
      ctx.lineWidth = 1;

      throbs.forEach((throb) => {
        const relTime = (throb.time - startTime.current) / 1000;
        if (relTime >= baseTime - WAVE_LENGTH_SEC && relTime <= baseTime) {
          const x = ((relTime - (baseTime - WAVE_LENGTH_SEC)) / WAVE_LENGTH_SEC) * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x, height / 2, 6, 0, 2 * Math.PI);
          ctx.fill();
        }
      });
    }, [waveData, throbs]);

    return <canvas ref={canvasRef} width={800} height={200} style={{ border: "1px solid #ccc" }} />;
  }

  return (
    <div style={{ fontFamily: "sans-serif", padding: 20 }}>
      <h2>Pulse Throb Monitor (Bluetooth)</h2>
      {!connected ? (
        <button onClick={connect}>Connect Bluetooth HR Monitor</button>
      ) : (
        <div>
          <p>Heart Rate: {hr} bpm</p>
          <WaveformCanvas />
          <button onClick={handleThrob} disabled={!recording} style={{ margin: "10px 0" }}>
            Mark Throb
          </button>
          <div>
            {!recording ? (
              <button onClick={startRecording}>Start Recording</button>
            ) : (
              <button onClick={stopRecording}>Stop Recording</button>
            )}
          </div>
          <p>Recording time: {elapsed.toFixed(1)} s</p>

          <h3>Recordings</h3>
          <ul>
            {records.map((rec) => (
              <li key={rec.id}>
                Recording {new Date(rec.id).toLocaleString()} â€”{" "}
                <button onClick={() => downloadCSV(rec)}>Download CSV</button>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
